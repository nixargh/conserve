#!/usr/bin/ruby
#### INFO ######################################################################
# Conserve
# script for backup
# (*w) author nixargh <nixargh@gmail.com>
$version = '1.9.16'
#### SETTINGS ##################################################################
$debug = false
ENV['PATH'] = "#{ENV['PATH']}:/sbin:/usr/sbin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin"
#### REQUIRE ###################################################################
require 'fileutils'

#### CLASES ####################################################################

class LVM_operate
	attr_accessor :lvm_block_size, :duplicate_warning
	
	def initialize
		@lvm_block_size = 4 # in megabytes
		@snapshot_size_part = 80 # % from Free PE of Volume Group
		@temp_log = '/tmp/lvcreate.log'
		@temp_log_err = '/tmp/lvcreate_err.log'
		@log = $log
		@snapshots_created = []
		@duplicate_warning = 0
	end
	
	def get_volume_group(volume)
		action = "lvdisplay -c #{volume}"
		info = do_it(action)[2]
		lvm_group = info.split(':')[1]
	end
	
	def ensure
		sleep 3
		@snapshots_created.each{|snapshot|
			lvm_s_del = delete_snapshot(snapshot)
			if lvm_s_del[0] == 0
				@log.write("\t\tSnapshot of #{snapshot} deleted. - [ #{green('OK')} ]")
			else
				@log.write("\t\tCan't delete #{snapshot} snapshot: #{lvm_s_del}.  - [ #{red('FAILED')} ]")
			end
		}
	end
	
	def create_snapshot(volume)
		begin
			status = 0
			snapshot = "#{File.basename(volume)}_backup"
			snapshot_size = find_space_for_snapshot(get_volume_group(volume)) * @snapshot_size_part
			snapshot_size = snapshot_size/100
			action = "lvcreate -l#{snapshot_size} -s -n #{snapshot} #{volume}"
			action_result = do_it(action)
			snapshot = File.dirname(volume) + "\/" + snapshot
			if action_result[0] == 0
				@snapshots_created.push(snapshot)
				raise "Could not find snapshot: #{snapshot}. Maybe it's not created." if File.exist?(snapshot) == false
			else
				raise action_result[1]
			end
		rescue
			status = 1
			error = $!
		end
		result = [status, error, snapshot]
	end

	def delete_snapshot(device)
		action = "lvremove -f #{device}"
		do_it(action)
	end

	def get_size(device)
		action = "lvdisplay #{device}"
		size = nil
		info = do_it(action)[2]
		(info.split("\n")).each{|line|
			size = line.split('Current LE')[1].lstrip! if line.index('Current LE')
		}
		size = size.to_i * @lvm_block_size * 1024 * 1024
		size # size in bytes
	end
###########
	private
###########
	def find_space_for_snapshot(lvm_group)
		action = "vgdisplay -c #{lvm_group}"
		info = do_it(action)[2]
		info = info.split(':')
		free_pe = (info[info.length - 2]).to_i # space in PE
	end
	
	def do_it(action)
		begin
			cmd_result = $operate.cmd_output(action)
			#`#{action} 2>#{@temp_log_err} 1>#{@temp_log}`
			#lv_error = IO.read(@temp_log_err)
			#lv_info = IO.read(@temp_log)
			raise "Can't get output of \"#{action}\": #{cmd_result[1]}" if cmd_result[0] != 0
			if cmd_result[3] == ''
			# second part to avoid SLES 11 sp.1 bug with "Unable to deact, open_count is 1" warning
				status = 0
				error = nil
			elsif cmd_result[3].index("give up on open_count") != nil
				# this is to avoid SLES 11 sp.1 bug with "Unable to deact, open_count is 1" warning
				@log.write(yellow("\t\tBuged lvremove detected. Warnings on snapshot remove."))
				status = 0
				error = nil
			elsif cmd_result[3].index("Found duplicate PV") != nil
				# this is to avoid duplication of block device with SLES11 on Hyper-V
				@log.write(yellow("\t\t\"duplicate PV\" SLES11 on Hyper-V problem detected. Continue backup process.")) if @duplicate_warning == 0
				status = 0
				error = nil
				@duplicate_warning = 1
			else
				raise cmd_result[3]
			end
		rescue
			status = 1
			error = $!
		ensure
			#File.unlink(@temp_log)
			#File.unlink(@temp_log_err)
		end
		result = [status, error, cmd_result[2]]
	end
end

class Backup
	attr_accessor :source, :destination, :share_type, :use_lvm, :mount_point, :credential_file, :archive, :mbr
	
	def initialize(source, destination)
		@destination = destination
		@source = source
		@share_type = 'smb'
		@mounted = []
		@use_lvm = true
		@mount_point = '/mnt'
		@credential_file = '/root/credential'
		@log = $log
		@mount_dir = []
		@archive = false
		@lvm = nil
		@source_is_blockdev = false
		@mbr = nil
	end
	
	def ensure
		@mounted.each{|share|
			`umount #{share}`
			@log.write("\tUnmounting #{share}. - [ #{green('OK')} ]")
		}
		@mount_dir.each{|directory|
			Dir.unlink(directory)
		}
		@lvm.ensure if @lvm
	end

	def create
		begin
			@log.write("")
			@log.write("Backup started - #{Time.now.asctime}")
			destination_parse = parse_and_mount(@destination)
			@source_is_blockdev = true if File.blockdev?(@source)
			source_parse = parse_and_mount(@source)
			destination_parse[0] == 0 ? destination_file = destination_parse[2] : (raise "\"parse_and_mount\" destination error: #{destination_parse[1]}")
			source_parse[0] == 0 ? source_file = source_parse[2] : (raise "\"parse_and_mount\" source error: #{source_parse[1]}")
			
			if File.blockdev?(source_file)
				if @mbr == true
					@log.write(yellow("\tBackup MBR from #{source_file} selected."))
					backup_mbr(source_file, destination_file)
				else
				# делаем образ со снепшота или просто с раздела
					@log.write("\tSource (#{source_file}) is a block device.")
					if @use_lvm == true
					# делаем снепшот
						@log.write(yellow("\tUse LVM selected by default."))
						@lvm = LVM_operate.new
						create_snapshot_result = @lvm.create_snapshot(source_file)
						if create_snapshot_result[0] == 0
							@log.write("\t\tSnapshot of #{source_file} created. - [ #{green('OK')} ]")
							source_file = create_snapshot_result[2]
						else
							raise "Snapshot creation failed with: #{create_snapshot_result[1]}"
						end
					end
					make_image(source_file, destination_file)
				end					
			else
			# бэкап копированием
				@log.write("\tSource (#{source_file}) isn't a block device.")
				if @use_lvm == true
				# делаем снепшот lvm
					@log.write(yellow("\tUse LVM selected by default.")) 
					volume = guess_file_volume(source_file)
					if volume[0] == 0
						@log.write("\t\tFound block device \"#{volume[2]}\" for source file(s): #{source_file}.")
						@lvm = LVM_operate.new
						create_snapshot_result = @lvm.create_snapshot(volume[2])
						if create_snapshot_result[0] == 0
							@log.write("\t\tSnapshot of #{volume[2]} created. - [ #{green('OK')} ]")
							source_vol = create_snapshot_result[2]
							mount_result = parse_and_mount(source_vol)
							if mount_result[0] = 0
								@log.write_noel("\t\t\tTrying to find #{source_file} on #{mount_result[2]}... - ")
								$stdout.flush								
								source_file = mount_result[2] + source_file.gsub(where_mounted?(volume[2]), '')
								if File.exist?(source_file)
									@log.write("[ #{green('OK')} ]")
								else
									@log.write("[ #{red('FAILED')} ]")
									raise "Can't find #{source_file}"
								end
							else
								raise "Can't mount #{source_vol}: #{mount_result[1]}"
							end
						else
							raise "Snapshot creation failed with: #{create_snapshot_result[1]}"
						end
					else
						raise "Can't find block device for file #{source_file}."
					end		
				end	
				# тарим и сжимаем если требуется
				@log.write_noel("\tRunning tar of #{source_file} to #{destination_file}, please wait... - ")
				tar_result = tar_create(source_file,destination_file)
				if tar_result[0] == 0
					@log.write("[ #{green('OK')} ]")
				else
					@log.write("[ #{red('FAILED')} ]")
					raise tar_result[1]
				end
			end
		rescue
			raise (red("\t*** ") + yellow(error = $!) + red(' ***'))
		end
	end

###########
	private
###########
	def get_partition_size(device)
		size = nil
		info = `fdisk -l #{device} 2>/dev/null`
		info.each_line{|line|
			if line.index(device)
				line = line.split(' ')
				size = line[line.length - 2]
			end
		}
		size.to_i
	end

	def backup_mbr(source_device, destination_file)
		if File.blockdev?(source_device)
			@log.write_noel("\tRunning MBR backup of #{source_device} to #{destination_file}, please wait... - ")
			`dd if=#{source_device} of=#{destination_file} bs=512 count=1 1>/dev/null 2>/dev/null`
			if File.exist?(destination_file)
				@log.write("[ #{green('OK')} ]")
			else
				@log.write("[ #{red('FAILED')} ]")
				raise "MBR backup destination file \"#{destination_file}\" not found"
			end
		else
			raise "Can't backup MBR: #{source_device} isn't a block device"
		end
	end

	def parse_and_mount(path)
		begin
			status = 0
			error = nil
			path = parse_path(path)
			raise "Path error: #{path[1]}" if path[0] == false
			if path[2] # есть в пути имя сервера
				path_new = "//#{path[2]}#{path[3]}"
				mount_result = mount(path_new, @mount_point, 'smb')
				file = "#{mount_result[2]}/#{path[4]}"
				raise "#{file} is a directory. You need to point destination file (-d) not a directory" if File.directory?(file)
			elsif File.blockdev?("#{path[3]}/#{path[4]}") && check_mounted("#{path[3]}/#{path[4]}")[0] == 1 && @source_is_blockdev == false
			# блоковое устройство и не примаунчено + изначально как --source выбиралось не блоковое устройство
				path_new = "#{path[3]}/#{path[4]}"
				mount_result = mount(path_new, @mount_point, 'local')
				file = mount_result[2]
			else # нет в пути имени сервера
				mount_result = [0,nil]
				file = "#{path[3]}/#{path[4]}"
			end
			# Тут бы нужно проверять наличие файла или папки...
			# raise "Can't find file \"#{file}\"" if File.exist?(file) == false
			raise "Can't mount device or network share: #{mount_result[1]}" if mount_result[0] != 0
			rescue
			status = 1
			error = $!
		end
		@source_is_blockdev = false
		result = [status, error, file]
	end

	def get_image_file_size(file)
		image_size = nil
		if File.extname(file) == '.gz'
			#puts "\t\tDetermining the size of image file archived in #{file},\n\t\tit can take anywhere from 5 minutes to an hour, depending on the size of the original image."
			image_size = `zcat #{file} |wc -c`
			image_size = image_size.chomp.to_i
		else
			image_size = File.size?(file)
		end
		image_size # size in bytes
	end
	
	def make_image(partition, path)
		begin
			@log.write_noel("\tRunning image creation of #{partition}, please wait... - ")
			size = nil
			@lvm ? (block_size = @lvm.lvm_block_size) : (block_size = 4)
			dd_log = '/tmp/dd.log'
			if archive == false
				`dd if=#{partition} of=#{path} bs=#{block_size}M 2>#{dd_log}`
			else
				path = "#{path}.gz"
				`dd if=#{partition} bs=#{block_size}M 2>#{dd_log} | gzip > #{path}`
			end
			info = IO.read(dd_log)
			if info.index("copied")
				partition_size = get_partition_size(partition)
				image_size = get_image_file_size(path)
				if partition_size == image_size
					@log.write("[ #{green('OK')} ]")
					@log.write_noel("\t\tSource size: #{yellow(format_size(partition_size))}; Image size: #{yellow(format_size(image_size))}")
					archive == true ? (@log.write("; Archived image size: #{yellow(format_size(File.size?(path)))}.")) : @log.write(".")
				else
					@log.write("[ #{red('FAILED')} ]")
					raise "image file size not equal to partition size: #{image_size} != #{partition_size}"
				end
			else
				raise info
			end
		ensure
			File.unlink(dd_log)
		end
	end
	
	def guess_file_volume(file)
		begin
			status = 0
			volume = nil
			file_path = parse_path(file)
			if file_path[0] == 0
				mount_list = IO.read('/etc/mtab')
				mount_list.each_line{|line|
					line = line.split(' ')
					#puts "#{line[0]} - #{line[1]}"
					#puts file_path[3].index(line[1])
					if file_path[3].index(line[1]) && line[1] != '/'
						volume = line[0]
					elsif file_path[3].index(line[1]) && line[1] == '/' && volume == nil

						volume = line[0]
					end
				}
				if volume.index('/dev/mapper/')
					group_volume = (volume.split('/')).last
					volume = group_volume[group_volume.index(/[^-]-[^-]/)+2..group_volume.length]
					group = group_volume[0..group_volume.index(/[^-]-[^-]/)].gsub('--','-')
					volume = "/dev/#{group}/#{volume}"
				end
			else
				raise file_path[1]
			end
		rescue
			status = 1
			error = $!
		end
		result = [status, error, volume]
	end
	
	def create_random_dir(where)
		# создаёт директорию куда монтировать в той что указана в where (т.е. корневая)
		# удаляется в функции ensure
		begin
			status = 0
			mount_dir = "#{where}/bak#{rand(1000000)}"
			raise "Can't create directory #{mount_dir}." if Dir.mkdir(mount_dir) != 0
			@mount_dir.push(mount_dir)
		rescue
			status = 1
			error = $!
		end
		result = [status, error, mount_dir]
	end
	
	def mount(what, where, type)
		begin
			status = 0
			path = nil
			if File.directory?(where)
				if type == 'smb'
					raise "You need to install \"mount.cifs\" (\"cifs-utils\" or \"smbfs\" packet on Ubuntu, \"cifs-mount\" on SLES) to mount SMB shares" if File.exist?(`which 'mount.cifs'`.chomp) == false
					@log.write("\tMounting SMB share...")
					server = (what.split("/"))[2]
					if check_online(server)[0] == 0
						random_dir = create_random_dir(where)
						random_dir[0] == 0 ? mount_dir = random_dir[2] : (raise "Can't create random directory: #{random_dir[1]}")
						create_cred_file if File.exist?(@credential_file) == false
						#credential_file = create_cred_file[2] if (credential_file = @credential_file) == nil
#				puts "mount -t cifs #{what} #{mount_dir} -o credential=#{@credential_file}"
						mount_stat = $operate.cmd_output("mount -t cifs #{what} #{mount_dir} -o credential=#{@credential_file}")
						mount_check = check_mount_stat(mount_stat, what, mount_dir)
						mount_check[0] == 0 ? (path = mount_dir) : (raise mount_check[1])
						test_file = "#{path}/test_file"
						begin
							File.open(test_file, 'w'){|file|
								file.puts('test')
							}
							File.unlink(test_file)
						rescue
							raise "Can't create file at mounted share \"#{what}\". Perhaps \"#{File.basename(what)}\" directory doesn't exist."
						end
					else
						raise "#{what[0]} isn't online."
					end
				elsif type == 'local'
					@log.write("\tMounting local disk...")
					random_dir = create_random_dir(where)
					random_dir[0] == 0 ? mount_dir = random_dir[2] : (raise "Can't create random directory: #{random_dir[1]}")
					mount_stat = $operate.cmd_output("mount #{what} #{mount_dir}")
					mount_check = check_mount_stat(mount_stat, what, mount_dir)
					mount_check[0] == 0 ? (path = mount_dir) : (raise mount_check[1])
				else
					raise "Can't work with that mount type: #{type}"
				end
			else
				raise "root mount directory \"#{where}\" not found or not a directory"
			end
		rescue
			status = 1
			error = $!
		end
		result = [status, error, path]
	end	
	
	def check_mount_stat(mount_stat, what, mount_dir)
		begin
			status = 0
			if mount_stat[3] != ''
				@log.write("\t\t#{what} NOT mounted to #{mount_dir}. - [ #{red('FAILED')} ]")
				raise mount_stat[3]
			elsif mount_stat[2] != '' && mount_stat[3] == ''
				@mounted.push(mount_dir)
				@log.write("\t\t#{what} mounted to #{mount_dir} with warnings: #{mount_stat[2]}. - [ #{green('OK')} ]")
			else
				@mounted.push(mount_dir)
				@log.write("\t\t#{what} mounted to #{mount_dir}. - [ #{green('OK')} ]")
			end
		rescue
			status = 1
			error = $!
		end
		result = [status, error]
	end

	def check_online(server)
		begin
			if server == nil
				raise 'Nothing to check, because "server" is nil.'
			end
			response = `ping -c 1 #{server} 2>/dev/null`
			online = response.split('packets transmitted, ')[1].split(' received')[0].to_i
			if online == 1
				status = 0
				error = nil
			elsif online ==0 
				status = 1
				error = "Ping of #{server} failed."
			else
				status = 2
				error = 'Undefined number of pings...'
			end
		rescue
			status = 1
			error = $!
		end
		result = [status, error]
	end
	
	def check_mounted(device)
		begin
			status = 0
			mounted = false
			mtab_list = `cat /etc/mtab`
			mtab_list.each_line{|line|
				mounted_device = line.split(" ")[0]
				if mounted_device.index(device)
					mounted = true
				else
					if mounted_device.index("mapper")
						splited_volume = mounted_device.split("/")
						volume_length = splited_volume.length
						lvm_data = splited_volume[volume_length - 1].split("-")
						volume = "/dev/#{lvm_data[0]}/#{lvm_data[1]}"
						mounted = true if volume.index(device)
					end
				end	
			}
			raise "#{device} not mounted" if mounted != true
		rescue
			status = 1
			error = $!
		end
		result = [status, error]
	end
	
	def where_mounted?(partition)
		partition = File.readlink(partition) if File.symlink?(partition)
		partition = partition.gsub('..','/dev')
		root = nil
		IO.read('/etc/mtab').each_line{|line|
			line.chomp!
			line = line.split(" ")
			root = line[1] if line[0] == partition
			#puts "partition = #{partition}\t\tline[0] = #{line[0]}\t\tline[1] = #{line[1]}\t\troot = #{root}\n"
		}
		root ? root : (raise "Can't find where #{partition} mounted")
	end
	
	def create_cred_file
		begin
			@log.write(yellow("\t\tCredential file \"#{@credential_file}\" not found. Let's create it..."))
			status = 0
			error = nil
			print sky_blue("\t\t\tEnter username to access shared resource: ")
			username = $stdin.gets.chomp
			print sky_blue("\t\t\tEnter password: ")
			system "stty -echo"
			password = $stdin.gets.chomp
			system "stty echo"
			if File.directory?(File.dirname(@credential_file))
				File.open(@credential_file, "w"){ |openfile|
					openfile.puts "username=#{username}"
					openfile.puts "password=#{password}"
				}
			else
				raise "Can't access #{File.dirname(@credential_file)} directory"
			end
		rescue
			status = 1
			error = $!
		ensure
			system "stty echo"
		end
		result = [status, error]
	end

	def tar_create(what, where)
		begin
			tar_log = '/tmp/tar.log'
			tar_error_log = '/tmp/tar_err.log'
			if @archive == true
				`tar -czf #{where}.tar.gz #{what} 1>#{tar_log} 2>#{tar_error_log}`
				ext = '.tar.gz'
			else
				`tar -cf #{where}.tar #{what} 1>#{tar_log} 2>#{tar_error_log}`
				ext = '.tar'
			end
			info = IO.read(tar_log)
			error_s = IO.read(tar_error_log)
			error_a = []
			error_s.each_line{|line|
				line.chomp!
				if line.index("tar: Removing leading `/\' from") == nil
					error_a.push(line)
				end
			}
			if error_a != [] && File.exist?("#{where}#{ext}")
			# тут бы конечно покрасивее сделать, а то по ошибке не будет ничего понятно толком
				raise "tar error: #{error_a}"
			else
				status = 0
				error = nil
			end
		rescue
			status = 1
			error = $!
		ensure
			File.unlink(tar_log, tar_error_log)
		end
		result = [status, error, info]
	end

end

class Log

	attr_accessor :log_file, :log_enabled, :start_time
	
	def initialize()
		@log_file = nil
		@log_enabled = false
		@start_time = nil
		@skip_time = false
	end
	
	def write(info)
		if @log_enabled == true
			to_log(info, "\n")
		else
			to_stdout(info, "\n")
		end
	end
	
	def write_noel(info)
		if @log_enabled == true
			to_log(info, '')
			@skip_time = true
		else
			to_stdout(info, '')
			$stdout.flush
		end
	end

	def to_stdout(info,el)
		print info + el
	end
	
	def to_log(info, el)
		begin
			File.open(@log_file, "a"){ |openfile|
					@start_time = Time.now.asctime
					if @skip_time == true
						openfile.print "#{info}#{el}"
						@skip_time = false
					else
						openfile.print "#{@start_time} - #{info}#{el}"
					end
				}
			status = 0
			error = nil
		rescue
			status = 1
			error = $!
		end
		result = [status, error]
	end
	
	
end

class Operate
	attr_accessor :destination
	
	def initialize
		@action = nil
		@log_file = nil
		@source = nil
		@destination = nil
		@mountdir = nil
		@use_lvm = nil
		@log_enabled = nil
		@cred_file = nil
		@archive = nil
		@module = nil
		@backup = nil
		@mbr = nil
		@inform = nil
		$argv = nil
		$job_name = nil
	end
	
	def ensure
		@backup.ensure if @backup != nil
		if @inform != nil
			inform = Inform.new
			inform.config_file = @inform
			inform.run
		end
	end

	def read_arguments()
		begin
			status = 0
			error = nil
			raise 'Nothing will happen without parametrs. Use "--help" for full list.' if ARGV == []
			$argv = ARGV
			ARGV.each{|arg|
				if arg == '-h' || arg == '--help'
					help
					exit 0
				elsif arg == '--no_lvm'
					@use_lvm = false
				elsif arg == '--gzip' || arg == '-z'
					@archive = true
				elsif arg.index('--log') == 0 || arg.index('-l') == 0
					@log_enabled = true
					raise "You must enter full log path." if (@log_file = arg.split('=')[1]) == nil
				elsif arg.index('--mbr') == 0
					@mbr = true
				elsif arg.index('--source') == 0 || arg.index('-s') == 0
					raise "You must enter source path." if (@source = arg.split('=')[1]) == nil
				elsif arg.index('--destination') == 0 || arg.index('-d') == 0
					raise "You must enter destination path." if (@destination = arg.split('=')[1]) == nil
				elsif arg.index('--mountdir') == 0 || arg.index('-m') == 0
					raise "You must enter root mount directory." if (@mountdir = arg.split('=')[1]) == nil
				elsif arg.index('--credential') == 0 || arg.index('-c') == 0
					raise "You must enter full path to credential file." if (@cred_file = arg.split('=')[1]) == nil
				elsif arg.index('--add_module') == 0 || arg.index('-a') == 0
					raise "You must enter full path to module file." if (@module = arg.split('=')[1]) == nil
				elsif arg.index('--inform') == 0 || arg.index('-i') == 0
					raise "You must enter full path to config file." if (@inform = arg.split('=')[1]) == nil
				elsif arg.index('--job_name') == 0 || arg.index('-n') == 0
					raise "You must enter backup job name." if ($job_name = arg.split('=')[1]) == nil
				elsif arg == '-v' || arg == '--version'
					puts "Conserve - backup tool v.#{$version} (*w)"
					exit 0
				elsif arg == '--debug'
					$debug == true
				else
					raise "Bad parametr #{arg}. Use \"--help\" for full list of parametrs."
				end
			}
		rescue
			status = 1
			error = $!
		end
		result = [status, error]
	end
	
	def action()
		begin
			status = 0
			error = nil
			$job_name = $argv if $job_name == nil
			if @log_enabled == true
				$log.log_enabled = true
				$log.log_file = @log_file
			end
			if @module != nil
					#puts "we will use #{@module} module."
					require @module
			else
				@backup = Backup.new(@source,@destination)
				@backup.mbr = true if @mbr == true
				@backup.use_lvm = false if @use_lvm == false
				@backup.mount_point = @mountdir if @mountdir != nil
				@backup.credential_file = @cred_file if @cred_file != nil
				@backup.archive = true if @archive == true
				@backup.create
			end
		rescue
			status = 1
			error = $!
		end
		result = [status, error]
	end

	def cmd_output(cmd)
		begin
			status = 0
			error = nil
			temp_log_err = '/tmp/conseve_cmd_err.log'
			temp_log = '/tmp/conseve_cmd.log'
			`#{cmd} 2>#{temp_log_err} 1>#{temp_log}`
			cmd_error = IO.read(temp_log_err)
			cmd_info = IO.read(temp_log)
		rescue
			status = 1
			error = $!
		ensure
			File.unlink(temp_log_err, temp_log)
		end
		result = [status, error, cmd_info, cmd_error] 
	end

	###########
	private
###########

	def help()
		puts "Conserve v.#{$version}
- is a backup tool, which can do:
	1. Backup block devices with LVM and dd.
	2. Backup MBR.
	3. Backup files from lvm snapshot or from \"live\" fs.
	4. Backup from and to smb shares.

Options:
	-l=	--log='file'\t\t\t\tfull path to logfile. Show info to console by default.
	-s=	--source='server|/dev/dev0'\t\tfull path to block device or files to backup
	-d=	--destination='server|/dir/file'\tfull path where to store backup
	\t\t\t\t\t\tif path isn't smb share then you just use local path to files;
	\t\t\t\t\t\tserver - server name where share is, /dir/file - files path on the share
		--no_lvm\t\t\t\tdo not use LVM snapshot
	-m=	--mountdir='/dir'\t\t\troot directory to mount network shares (\"/mnt\" by default)
	-c=	--credential='file'\t\t\tfull path to file with smb credentials. File format as for cifs mount.
	-z	--gzip\t\t\t\t\tarchive block device image by gzip or tar and gzip files when backuping non block device
	-a=	--add_module='/dir/module_file'\t\tadd module for some specific backup
	\t--mbr\t\t\t\t\tbackup MBR from device pointed like source
	-i=	--inform='/dir/inform.conf'\t\tinform about backup status as described at config file
	\t\t\t\t\t\tif no config file found it will be created
	-n=	--job_name='Daily MBR Backup'\t\tset display name for backup job (equal to given conserve parametrs by default)
		
	-h	--help\t\t\t\t\tto show this help
	-v	--version\t\t\t\tto show Conserve version
		--debug\t\t\t\t\tshow more information about code errors 
"
	end
end	

class Inform
	attr_accessor :config_file

	def initialize
		@config_file = config_file #config file
		@config = nil # configuration hash
		@log = $log
		@log.write("\t#{yellow("Inform function was activated.")}")
		ruby_gems = Ruby_gems.new
		if ruby_gems.check_rubygems == false
			text = "#{red("\t\t\"ruby gem\" utility not installed. Inform function require it.")}"
			@log.write(text)
			puts text
			ruby_gems.install_rubygems
		end
		if ruby_gems.gem_installed?('mail') == false
			text = "#{red("\t\t\"mail\" ruby gem not installed. Inform function require it.")}"
			@log.write(text)
			puts text
			ruby_gems.install_mail_gem
		end
		if ruby_gems.check_rubygems
			require 'rubygems'
			if  ruby_gems.gem_installed?('mail')
				require 'mail'
			else
				raise "\"mail\" ruby gem not installed"
			end
		else
			raise "\"ruby gem\" utility not installed"
		end
	end

	def run
		read_config
		if @config['when_inform'] == 'all'
			report = true
		elsif @config['when_inform'] == 'fail' && $global_error
			report = true
		elsif @config['when_inform'] == 'success' && $global_error == nil
			report = true
		else
			report = false
		end
		if report
			@log.write("\t\t#{yellow("Creating report:")} method \"#{@config['method']}\".")
			if @config['method'] == 'email'
				send_mail
		
			end
		else
			@log.write("\t\t#{yellow("Nothing to report:")} report case \"#{@config['when_inform']}\" selected.")
		end
	end
		
###########
	private
###########
	def color_schema(item)
		if @config['colors'] == 'console'
			colors = {
				'background' => 'black',
				'log_text' => 'gray',
				'main_text' => 'white',
				'h_red' => 'red',
				'h_green' => 'green',
				'h_yellow' => 'yellow',
				'h_sky_blue' => 'sky_blue'
			}
		elsif @config['colors'] == 'white'
			colors = {
				'background' => 'white',
				'log_text' => 'black',
				'main_text' => 'blue',
				'h_red' => 'red',
				'h_green' => 'green',
				'h_yellow' => 'orange',
				'h_sky_blue' => 'sky_blue'
			}
		end
		colors[item]
	end

	def log_to_html(info)
		red = "\e[31m"
		green = "\e[32m"
		yellow = "\e[33m"
		sky_blue = "\e[36m"
		teg_close = "\e[0m"

		h_red = "<font color=\"#{color_schema('h_red')}\">"
		h_green = "<font color=\"#{color_schema('h_green')}\">"
		h_yellow = "<font color=\"#{color_schema('h_yellow')}\">"
		h_sky_blue = "<font color=\"#{color_schema('h_sky_blue')}\">"
		h_teg_close = '</font>'
		
		html_info = Array.new
		info = s_to_a(info)
		info.each{|line|
			line.gsub!(red, h_red)
			line.gsub!(green, h_green)
			line.gsub!(yellow, h_yellow)
			line.gsub!(sky_blue, h_sky_blue)
			line.gsub!(teg_close, h_teg_close)
			html_info.push("#{line}<br>")
		}
		html_info
	end
	
	def create_body(info)
		body = Array.new
		last_backup = compact_log(info, 'last')
		if $global_error
			text = 'Backup Job Failed.'
			color = 'red'
		else
			text = 'Backup Job Successfully Completed.'
			color = 'green'
		end
		body.push("<html><body bgcolor=\"#{color_schema('background')}\" text=\"#{color_schema('log_text')}\">\n<pre>\n")
		body.push("<font size=\"12\" color=\"#{color}\" face=\"Arial\">#{text}</font>")
		body.push("<br><font color=\"#{color_schema('main_text')}\"><pre>conserve v.#{$version} #{form_arguments_list($argv)}</pre></font><br>")
		body.push(log_to_html(last_backup))
		body.push("\n</pre>\n</body></html>")
		body
	end
	
	def create_attach(info)
		log_html = log_to_html(info)
		attach = Array.new
		attach.push("<html><body bgcolor=\"black\" text=\"gray\">\n<pre>\n")
		attach.push(log_html)
		attach.push("\n</pre>\n</body></html>")
	end

	def form_arguments_list(arguments)
		arg_string = String.new
		arg_string << "\n"
		arguments.each{|arg|
			arg_string << "\t#{arg}\n"
		}
		arg_string
	end
	
	def create_subject
		hostname = get_hostname
		if $global_error
			"#{hostname}: Conserve Backup Job \"#{$job_name}\" Failed."
		else
			"#{hostname}: Conserve Backup Job \"#{$job_name}\" Success."
		end
	end
	
	def compact_log(info, num_of_lines) # can compact by number of lines from the end or get the last backup info
		info = s_to_a(info)
		info_length = info.length
		if num_of_lines == 'last'
			first_line = info.rindex{|line|
				/ - Backup started - / =~ line
			}
			info_tail = info[first_line..info_length-1]
		else
			info_tail = info[(info_length - num_of_lines)..info_length-1]
		end
	end
	
	def check_potential_log_size(info)
		begin
			tmp_file = '/tmp/canserve.log.html'
			File.open(tmp_file, 'w'){|file|
				file.puts(info)
			}
			File.size?(tmp_file)
		rescue
			raise "Can't check potential conserve log size: #{$!}"
		ensure
			File.unlink(tmp_file)
		end
	end
	
	def send_mail
		error = false
		begin
			config = @config
			options = { 
					:address              => config['smtp_server'],
					:port                 => 25,
					:domain               => get_hostname
				}
		
			if config['auth'] == 'y'
				options.update(
					:authentication       => 'login',
					:user_name            => config['auth_user'],
					:password             => config['auth_pass']
				)
				
			end
		
			if config['tls'] == 'y'
				options.update(
					:enable_starttls_auto => true
				)
			elsif config['tls'] == 'n'
				options.update(
					:enable_starttls_auto => false
				)
			end
			
			Mail.defaults do
				delivery_method :smtp, options
			end
			
			log = File.read(@log.log_file)
			if check_potential_log_size(log) >= 2097152
				rest_lines = 300
				@log.write("\t\tHTML log size more than 2 Mb, compacting to #{yellow(rest_lines)} lines from the end.")
				log = compact_log(log, rest_lines)
			end
		
			body_html = create_body(log)
			attach_html = create_attach(log)
			diff_subject = create_subject
			
			if config['attach_log'] == 'y'
				mail = Mail.new do
					from     config['mail_from']
					to       config['mail_to']
					subject  diff_subject
					html_part do
						content_type 'text/html; charset=UTF-8'
						body body_html
					end
					add_file :filename => 'conserve.log.html', :content => attach_html
				end
			else	
				mail = Mail.new do
					from     config['mail_from']
					to       config['mail_to']
					subject  diff_subject
					html_part do
						content_type 'text/html; charset=UTF-8'
						body body_html
					end
				end
			end
			mail.deliver!
		rescue Net::SMTPFatalError
			error = $!
		rescue Net::SMTPAuthenticationError
			error = $!
		rescue SocketError
			error = $!
		rescue => detail
			@log.write(detail.backtrace.join("\n"))
			error = $!
		end
		@log.write("\t#{red("Inform Error:")} #{yellow(error)}") if error
	end
	
	def get_hostname
		hostname = `hostname`
		hostname.chomp!
	end

	def read_config
		create_config if File.exist?(@config_file) == false
		@log.write_noel("\t\tReading Inform configuration - ")
		if @config == nil
			@config = Hash.new
			IO.read(@config_file).each_line{|line|
				line = line.chomp.split('=', 2)
				@config[line[0]] = line[1]
			}
		end
		if @config
		 	@log.write("[ #{green('OK')} ]")
		else
			@log.write("[ #{red('FAILED')} ]")
			raise "Can't read and create Inform config: #{$!}"
		end
	end
	
	def create_config
		@log.write("#{yellow("\t\t#{@config_file} file not found. Let's create it:")}")
		conf_info = Hash.new
		begin
			print sky_blue("\t\t\tAbout which events to inform? [fail|success|all]: ")
			when_inform = $stdin.gets.chomp
		end while when_inform != 'fail' && when_inform != 'success' && when_inform != 'all'
		conf_info['when_inform'] = when_inform
		puts "#{sky_blue("\t\t\tSelect inform method [email]: ")} email"
		conf_info['method'] = 'email'
		begin
			print sky_blue("\t\t\tSelect color schema for report? [console|white]: ")
			conf_info['colors'] = $stdin.gets.chomp
		end while conf_info['colors'] != 'console' && conf_info['colors'] != 'white'
		begin
			print sky_blue("\t\t\tAttach log file to report? [y|n]: ")
			conf_info['attach_log'] = $stdin.gets.chomp
		end while conf_info['attach_log'] != 'y' && conf_info['attach_log'] != 'n'
		begin
			print sky_blue("\t\t\tUse TLS to connect to server? [y|n]: ")
			conf_info['tls'] = $stdin.gets.chomp
		end while conf_info['tls'] != 'y' && conf_info['tls'] != 'n'
		if conf_info['method'] == 'email'
			print sky_blue("\t\t\tSMTP server?: ")
			conf_info['smtp_server'] = $stdin.gets.chomp
			begin
				print sky_blue("\t\t\tAuthenticate before send? [y|n]: ")
				auth = $stdin.gets.chomp
			end while auth != 'y' && auth != 'n'
			conf_info['auth'] = auth
			if conf_info['auth'] == 'y'
				print sky_blue("\t\t\tUsername: ")
				conf_info['smtp_user'] = $stdin.gets.chomp
				print sky_blue("\t\t\tPassword: ")
				system "stty -echo"
				conf_info['smtp_pass'] = $stdin.gets.chomp
				system "stty echo"
			end
			print sky_blue("\t\t\tSend mail to: ")
			conf_info['mail_to'] = $stdin.gets.chomp
			print sky_blue("\t\t\tSend copy to: ")
			conf_info['copy_to'] = $stdin.gets.chomp
			print sky_blue("\t\t\tSend mail from: ")
			conf_info['mail_from'] = $stdin.gets.chomp
		end
		if File.directory?(File.dirname(@config_file))
			File.open(@config_file, "w"){ |openfile|
				conf_info.each{|option, value|
					openfile.puts "#{option}=#{value}"
				}
			}
		else
			raise "Can't access #{File.dirname(@config_file)} directory"
		end
		@config = conf_info
	end
end

class Ruby_gems
	def initialize
		@log = $log
		@rpm_download_site = 'voron-ok-radio.org'
		@SLES11_i586_rpm_dir = '/conserve/additional_rpms/SLES11/i586'
		@SLES11_i586_rpms = ['ruby-1.8.7.p352-1.1.i586.rpm', 'ruby-devel-1.8.7.p352-1.1.i586.rpm', 'rubygems-1.3.7-10.1.i586.rpm']
	end
	
	def install_rubygems
		answer = nil
		while answer != 'y' && answer != 'n' do
			print "\t\tWould you like to install \"ruby gem\" utility from ftp://voron-ok-radio.org? [y|n]: "
			answer = $stdin.gets.chomp
		end
		if answer == 'n'
			raise "Inform aborded"
		else
			begin
				download_dir = "/tmp/ruby_rpms_temp"
				Dir.mkdir(download_dir)
				Dir.chdir(download_dir)
				get_rubygems_rpms
				install_rubygems_rpms
			ensure
				Dir.entries(download_dir).each{|file|
					File.unlink(file) if file != '.' && file != '..'
				}
				Dir.unlink(download_dir)
				Dir.chdir
			end
		end
	end
	
	def check_rubygems
		gem = `which gem 2>/dev/null`.chomp
		gem == '' ? false : gem
	end
	
	def gem_installed?(gem)
		gem_cmd = check_rubygems
		if gem_cmd
			`#{gem_cmd} list #{gem}`.index('mail') ? true : false
		end
	end
	
	def install_mail_gem
		answer = nil
		while answer != 'y' && answer != 'n' do
			print "\t\tWould you like to install \"mail\" ruby gem? [y|n]: "
			answer = $stdin.gets.chomp
		end
		if answer == 'n'
			raise "Inform aborded"
		else
			install_gem('mail')
		end
	end

###########
	private
###########
	
	def detect_os
		rel_file = nil
		Dir.entries('/etc').each{|file|
			rel_file = file if /-release/ =~ file
		}
		rel_info = IO.read("/etc/#{rel_file}")
		rel_info = s_to_a(rel_info)
		if rel_info[0].index('SUSE Linux Enterprise Server 11')
			os = 'SLES11' if rel_info[2].chomp == 'PATCHLEVEL = 0'
			os = 'SLES11 sp.1' if rel_info[2].chomp == 'PATCHLEVEL = 1'
			arch = ((rel_info[0].split('('))[1].split(')'))[0]
		elsif rel_info[0] == 'DISTRIB_ID=Ubuntu'
			os = 'Ubuntu'
			arch = nil
		end
		result = [os, arch]
	end
	
	def install_gem(gem)
		gem_cmd = check_rubygems
		if gem_cmd
			@log.write("\t\t\tInstalling ruby gem \"#{gem}\"...")
			`#{gem_cmd} install #{gem}`
		else
			raise "Failed to find \"ruby gem\" utility"
		end
	end
	
	def	get_rubygems_rpms
		begin
			# use net/ftp
			require 'net/ftp'
			ftp = Net::FTP.new
			ftp.connect(@rpm_download_site,21)
			ftp.login('anonymous', '1212121212')
			# detect OS and arch to understand what rpms to download
			os = detect_os
			if (os[0] == 'SLES11' || os[0] == 'SLES11 sp.1')
				@log.write("\t\t\t#{os[0]} with #{os[1]} architecture detected.")
				ftp.chdir(@SLES11_i586_rpm_dir) if os[1] == 'i586'
			else
				raise "Don't have FTP directory for \"#{os[0]}\" #{os[1]}"
			end
			@SLES11_i586_rpms.each{|file|
				@log.write("\t\t\tDownloading #{file} from #{@rpm_download_site}...")
				ftp.getbinaryfile(file,"./#{file}")
			}
		rescue LoadError
			# use wget
			raise "NEED TO WRITE FTP DOWNLOAD WITH \"WGET\""
		rescue RuntimeError
			raise "FTP download failed: #{$!}"
		rescue
			raise "FTP download failed: #{$!}"
		ensure
			ftp.close
		end
	end
	
	def install_rubygems_rpms
		Dir.entries(Dir.pwd).each{|file| 
			if /ruby-\d/ =~ file
				@log.write("\t\t\tUpgrading ruby by #{file}...")
				`rpm -U #{file} 2>/dev/null`
			end
		}
		Dir.entries(Dir.pwd).each{|file|
			if /ruby-devel-\d/ =~ file
				@log.write("\t\t\tInstalling #{file}...")
				`rpm -i #{file} 2>/dev/null`
			end
		}
		Dir.entries(Dir.pwd).each{|file|
			if /rubygems-\d/ =~ file
				@log.write("\t\t\tInstalling #{file}...")
				`rpm -i #{file} 2>/dev/null`
			end
		}
	end
end
#### FUNCTIONS #################################################################
def s_to_a(string)
	if string.kind_of?(Array)
		string
	elsif string.kind_of?(String)
		array = string.split("\n")
	else
		raise "#{string} isn't string or array"
	end
end

def parse_path(path)
	begin
		status = 0
		error = nil
		server = nil
		file = nil
		if path != nil && path != 'module'
			path.gsub!('\\', '/')
			if path.index('|')
				path = path.split('|')
				server = path[0]
				path = path[1]
				file = File.basename(path)
				directory = File.dirname(path)
			else
				file = File.basename(path)
				if File.directory?(path)
					directory = path
					file = nil
				elsif File.directory?(file)
					directory = "#{File.dirname(path)}/#{file}"
				else
					directory = File.dirname(path)
				end
				if 	File.exist?(directory) && File.directory?(directory)
				else
					raise "Can't find directory - #{directory}"
				end
			end
		elsif path != nil && path == 'module'
		else
			raise "path is \"nil\""
		end
	rescue
		status = 1
		error = $!
	end
	result = [status, error, server, directory, file]
end

def colorize(text, color_code)
  "#{color_code}#{text}\e[0m"
end

def red(text); colorize(text, "\e[31m"); end
def green(text); colorize(text, "\e[32m"); end
def yellow(text); colorize(text, "\e[33m"); end
def sky_blue(text); colorize(text, "\e[36m"); end

def format_size(bytes_size)
	fromated_size = nil
	if bytes_size != nil
		units = ['b', 'Kb', 'Mb', 'Gb', 'Tb']
		index = 0
		size = bytes_size
		until (size / 1024) <= 1
			index += 1
			size = size / 1024
		end
		fromated_size = "#{size.round} #{units[index]}"
	end
	fromated_size
end
#### PROGRAM ###################################################################
begin
	$log = Log.new
	$operate = Operate.new
	if (read_arg_result = $operate.read_arguments)[0] == 0
		result = $operate.action
		raise result[1] if result[0] != 0
	else
		raise read_arg_result[1]
	end
rescue => detail
	@log.write(detail.backtrace.join("\n")) if $debug
	$global_error = $!
	$log.write("\t#{red("Error:")} #{yellow($global_error)}")
ensure
	$operate.ensure
end
